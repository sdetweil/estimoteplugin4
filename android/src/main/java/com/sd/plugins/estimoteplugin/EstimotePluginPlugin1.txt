package com.sd.plugins.estimoteplugin

import com.getcapacitor.JSObject
import com.getcapacitor.Plugin
import com.getcapacitor.PluginCall
import com.getcapacitor.PluginMethod
import com.getcapacitor.annotation.CapacitorPlugin


import android.util.Log;
import java.util.Calendar;
import kotlinx.coroutines.Job

import androidx.appcompat.app.AppCompatActivity


import com.estimote.uwb.api.EstimoteUWBFactory;
import com.estimote.uwb.api.scanning.EstimoteUWBScanResult;
import com.estimote.uwb.api.ranging.EstimoteUWBRangingResult;
import com.estimote.uwb.api.*

import com.estimote.uwb.api.scanning.EstimoteDevice

import kotlinx.coroutines.flow.*

import kotlin.collections.hashMapOf
import androidx.lifecycle.lifecycleScope
import com.getcapacitor.annotation.*

import kotlinx.coroutines.job
import kotlinx.coroutines.launch

@CapacitorPlugin(
    name = "EstimotePlugin"
    /*permissions = {
        @Permission(alias = "bluetooth", strings = { Manifest.permission.BLUETOOTH_SCAN }),
        @Permission(strings = { Manifest.permission.UWB_RANGING }, alias = "UWB")
    }*/
)
class EstimotePluginPlugin : Plugin() {
    //private val implementation = EstimotePlugin()
    //private var ListenerKey = "UWBInfo"
    private var ids = emptyArray<String>()
    private var job: Job? = null;

    private lateinit var ourContext : AppCompatActivity ;
    private val managerHandles = hashMapOf<String, EstimoteUWBManager>();

    private final fun getMS(): String {
        return Calendar.getInstance().timeInMillis.toString();
    };

    @PluginMethod
    fun echo(call: PluginCall) {
        val value = call.getString("value")
        Log.i("estimotePlugin", "input value=${value}")
        val ret = JSObject()
        ret.put("handle", value)
        call.resolve(ret)
    }

    @PluginMethod
    fun createManager(call: PluginCall) {
        ourContext = this.activity;
        Log.i("estimoteplugin", "createManager enter");
        val timeKey: String = getMS();
         Log.i("estimoteplugin", "createManager enter $timeKey");
        // estimote api for createManager
        //val uwbManager: String = "foo"
        val uwbManager:EstimoteUWBManager = EstimoteUWBFactory.create();
        //uwbManager.init(ourContext);
        managerHandles[timeKey] = uwbManager;

        Log.i("estimoteplugin", "createManager exit $timeKey");
        val ret = JSObject()
        ret.put("handle", timeKey)
        call.resolve(ret)
    }

    @PluginMethod
    fun startScanning(call: PluginCall) {
        val manager = call.getString("handle", "")
        Log.i("estimoteplugin","startscanning enter manager = $manager");
        val shouldConnectOnDiscovery = call.getBoolean("autoConnect", true)
        // save the restricted list of beacon ids, came in as comma separated values
        ids = call.getString("IDs", "")!!.split(",".toRegex()).dropLastWhile { it.isNotEmpty() }
            .toTypedArray()
        // get the manager handle from the hash
        val uwbManager: EstimoteUWBManager? = managerHandles[manager]
        // if set

        if (uwbManager != null) {
            Log.i("estimoteplugin", "scanning uwbmanager found")
            // if job hasn't been started or has been stopped
            if (job == null || !job!!.job.isActive && shouldConnectOnDiscovery== true) {
                // loop thru each of the devices
                Log.i("estimoteplugin", "scanning job not started")
                uwbManager.uwbDevices.onEach { scanResult: EstimoteUWBScanResult ->
                    when (scanResult) {
                        // if this is a scanresult
                        is EstimoteUWBScanResult.Devices -> {
                            Log.i(
                                "estimoteplugin",
                                "UWB Found ${scanResult.devices.size} UWB Beacons"
                            )
                            job = null;

                            // create a new job for processing the results
                            job = this.activity.lifecycleScope.launch {
                                // loop thru the devices found
                                scanResult.devices.onEach { beacon: EstimoteDevice ->
                                    // if no specific devices, OR this one matches
                                    if (ids.isEmpty() || ids.contains(beacon.deviceId)) {
                                        // report it to the app
                                        val data = JSObject()
                                        data.put("type", "discover");
                                        data.put("distance", beacon.rssi.toString())
                                        data.put("device", beacon.deviceId)
                                        // notify app listeners we found a beacon
                                        notifyListeners("estimoteplugin", data)
                                        // if we should connect on discovery
                                        if (shouldConnectOnDiscovery == true) {
                                            // do it
                                            beacon.device?.let {
                                                uwbManager.connect(
                                                    it,
                                                    ourContext
                                                )
                                            }
                                        };
                                    }
                                }
                            }
                        }

                        is EstimoteUWBScanResult.Error -> {
                            Log.e("UWB", "Error: ${scanResult.errorCode}")
                        }

                        is EstimoteUWBScanResult.ScanNotStarted -> {
                            Log.i("estimoteplugin", "UWB Error: scan not started")
                        }

                        else -> {}
                    }
                }.launchIn(this.activity.lifecycleScope)

                // process ranging results after connected
                uwbManager.rangingResult.onEach { rangingResult: EstimoteUWBRangingResult ->
                    when (rangingResult) {
                        // if this is a position ranging result
                        is EstimoteUWBRangingResult.Position -> {
                            // built the data to send to app
                            val data = JSObject()
                            Log.i(
                                "estimoteplugin",
                                "UWB ${rangingResult.position.distance?.value.toString()}"
                            )
                            if (rangingResult.position.azimuth !== null) {
                                data.put("vector", rangingResult.position.azimuth.toString())
                            }
                            data.put("type", "updatePosition");
                            data.put(
                                "distance",
                                rangingResult.position.distance?.value.toString()
                            )
                            data.put("device", rangingResult.device.hashCode().toString())
                            // notify app listeners
                            notifyListeners("estimoteplugin", data)
                        }

                        is EstimoteUWBRangingResult.Error -> {
                            Log.i("estimoteplugin", "UWB Error: ${rangingResult.message}")
                        }

                        else -> Unit
                    }
                }.launchIn(this.activity.lifecycleScope)
            }
            // start the scanning process, the handlers above will trigger
            Log.i("estimoteplugin", "scanning uwbstart scanner")
            uwbManager.startDeviceScanning(ourContext)
        }
        Log.i("estimoteplugin","startscanning exit")
        val ret = JSObject()
        ret.put("empty", 1)
        call.resolve(ret)
    }

    @PluginMethod
    fun stopScanning(call: PluginCall) {
        //print("stop scanning entered");
        val manager = call.getString("handle")
        // if there IS a job, and its active

        if(job?.job?.isActive == true) {
            // stop it
            managerHandles[manager]?.stopDeviceScanning();
            // and stop the job
            job?.job?.cancel()
        }

        // clear the restricted list of ids
        ids = emptyArray<String>()
        val ret = JSObject()
        ret.put("empty", 1)
        call.resolve(ret)
    }

    @PluginMethod
    fun connect(call: PluginCall) {
        val manager = call.getString("handle", "")
        val beacon = call.getString("beacon", "")

       // managerHandles[manager]?.connect(, ourContext);

        val ret = JSObject()
        ret.put("empty", manager + beacon)
        call.resolve(ret)
    }

    @PluginMethod
    fun disconnect(call: PluginCall) {

        val manager = call.getString("handle", "")
        val beacon = call.getString("beacon", "")

        //managerHandles[manager]?.disconnect(, ourContext);
        val ret = JSObject()
        ret.put("empty", manager + beacon)
        call.resolve(ret)
    }
}